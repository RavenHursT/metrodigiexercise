<?php

/**
 * @author     Jeffrey D. King
 * @copyright  2012- Weather Source, LLC
 * @since      Version 3.0
 */




/**
 *  Class to manage multithreaded cURL requests
 *
 *  Example usage:
 *
 *  <code>
 *
 *      // Process results as individual requests complete (rather than waiting
 *      // for all requests to complete) by defining a callback function.
 *
 *      /**
 *       *  User defined callback function to process results as the individual request completes
 *       *
 *       *  @ param   $response   string  The response to the cURL response. Prepend with '&' to pass by reference.
 *       *  @ param   $metadata   string  User defined metadata associated with the request
 *       *  @ param   $http_code  string  The HTTP code generated by the cURL request
 *       *  @ param   $latency    float   Seconds elapsed since node added accurate to the nearest microsecond
 *       *  @ param   $url        string  User provided URL
 *       *  @ param   $opts       array   The cURL transfer options
 *       *  @ return  whatever you define
 *       * /
 *      function user_defined_callback( &$response, $metadata, $http_code, $latency, $url, $opts ) {
 *
 *          // do something with $response
 *      }
 *
 *      // URLs to requests
 *      $urls = array(
 *          'http://www.example.com',
 *          'http://www1.example.com',
 *          'http://www2.example.com',
 *      );
 *
 *      // Pace your requests:
 *      Curl_Node::set_max_requests_per_minute(60);
 *
 *      // Only allow 10 threads at a time
 *      Curl_Node::set_max_threads(10);
 *
 *      foreach( $urls as $url ) {
 *
 *          // Add a cURL node to be processed as thread availability allows
 *          $node->new Curl_Node(
 *              $url,
 *              array( CURLOPT_TIMEOUT => 60, CURLOPT_CONNECTTIMEOUT => 5 ),
 *              'user_defined_callback'
 *          );
 *
 *          // use of the two instance methods
 *          if( 'complete' == $node->get_status() ) {
 *              $result = $node->get_result();
 *          }
 *      }
 *
 *      // Once all the nodes are added, wait for requests to complete
 *      Curl_Node::finish();
 *
 *      // Get an array of results
 *      // $results format:
 *      //     array(
 *      //        array(
 *      //            'response'  => string,    // Response message
 *      //            'metadata'  => string,    // User defined metadata associated with the request
 *      //            'http_code' => mixed,     // HTTP response code, 0 for cURL error
 *      //            'latency'   => float,     // Seconds elapsed since node added accurate to the nearest microsecond
 *      //            'url'       => string,    // User provided URL
 *      //            'opts'      => array,     // User provided cURL transfer options
 *      //        ),
 *      //        ...
 *      //     ),
 *      $results = Curl_Node::get_results();
 *
 *  </code>
 */
class Curl_Node {


    /**
     *  @access  private
     *  @static
     *  @var     array  Stack of queued requests
     */
    static private $queue;


    /**
     *  @access  private
     *  @static
     *  @var     array  Stack of active requests
     */
    static private $active;


    /**
     *  @access  private
     *  @static
     *  @var     array  Stack of completed requests
     */
    static private $complete;


    /**
     *  @access  private
     *  @static
     *  @var     resource  Global store for the cURL multi handle
     */
    static private $multi_handle;


    /**
     *  @access  private
     *  @static
     *  @var     integer  Count of active threads
     */
    static private $threads;


    /**
     *  @access  private
     *  @static
     *  @var     integer  Status of the multi cURL stack
     */
    static private $status;


    /**
     *  @access  private
     *  @static
     *  @var     boolean  Indicates whether nodes are currently being added.
     *                    Used to lock self::add_nodes() to a single concurrent
     *                    loop.
     */
    static private $add_nodes_lock;


    /**
     *  @access  private
     *  @static
     *  @var     integer  Upper limit for quantity of threads
     */
    static private $max_threads = 1;


    /**
     *  @access  private
     *  @static
     *  @var     integer  The maximum number of retries if a request suffers
     *                    a potentially recoverable failure.
     */
    static private $max_retries = 10;


    /**
     *  @access  private
     *  @static
     *  @var     integer  Upper limit for the number of requests allowed
     *                    per minute
     */
    static private $max_requests_per_minute = 10;


    /**
     *  @access  private
     *  @static
     *  @var     integer  Initial allowable requests per minute for
     *                    warm-up scaling.
     */
    static private $scaling_initial_requests_per_minute = 1000;


    /**
     *  @access  private
     *  @static
     *  @var     float  The number of minutes to double warm-up scaling
     *                  allowable requests per minute.
     */
    static private $scaling_double_capacity_minutes = 7;


    /**
     *  @access  private
     *  @static
     *  @var     integer  The UNIX timestamp when warm-up scaling began.
     */
    static private $scaling_initialization_timestamp;


    /**
     *  @access  private
     *  @static
     *  @var     boolean  If set to true, every time a request is queued, '+' is output,
     *                    every time a request is made, '-' is output, and every time a
     *                    response is received for a request '×' is output.
     */
    static private $show_progress = FALSE;


    /**
     *  @access  private
     *  @static
     *  @var     boolean  Log debug information?
     */
    static private $debug = FALSE;


    /**
     *  @access  private
     *  @static
     *  @var     string  All debug information is stored to this property.
     */
    static private $debug_info = '';


    /**
     *  @access  private
     *  @var     string  An individual cURL handle cast to a string. Used as
     *                   a unique id for efficient lookup from the self::$queue,
     *                   self::$active, and self::$complete stacks
     */
    private $handle_string;


    /**
     *  Initiate a class instance and add a request to multithreaded cURL handler
     *
     *  @access  public
     *  @param   string  $url       [REQUIRED]  URL for the cURL request
     *  @param   array   $opts      [OPTIONAL]  An array of cURL options formatted like:
     *                                          array( CURLOPT_URL => 'http://example.com' )
     *  @param   callable   $callback  [OPTIONAL]  If provided, the user defined callback
     *                                          function will be called as this individual
     *                                          request completes. You do not need to wait
     *                                          for everything to finish!
     *  @param   array   $metadata  [OPTIONAL]  A container to attach any information you
     *                                          want to associate with this request.
     *  @return  NULL
     */
    public function __construct( $url, $opts = array(), $callback = '', $metadata = array() ) {

        // set our warm-up scaling timestamp if it is not already set
        if( !isset(self::$scaling_initialization_timestamp) ) {
            self::$scaling_initialization_timestamp = time();
        }

        // force return of output
        $opts[CURLOPT_HEADER]         = 0;
        $opts[CURLOPT_RETURNTRANSFER] = 1;
        $opts[CURLOPT_URL]            = $url;
        $opts[CURLOPT_HTTPHEADER]     = array('Expect:'); // prevent HTTP 100:Continue responses

        $handle = curl_init();

        foreach($opts as $option => $value) {

            curl_setopt( $handle, $option, $value );
        }

        $node['handle']       = $handle;
        $node['url']          = $url;
        $node['opts']         = $opts;
        $node['start']        = microtime(TRUE);
        $node['latency']      = 0;
        $node['retries']      = 0;
        $node['http_code']    = '';
        $node['response']     = '';
        $node['callback']     = $callback;
        $node['metadata']     = $metadata;

        self::$queue[(string) $handle] = $node;

        if( self::$debug ) self::$debug_info += ((string) $handle) . ": added to queue\n";
        if( self::$show_progress ) echo '+';

        self::request();

        $this->handle_string = (string) $handle;
    }


    /**
     *  Set the initial allowable requests per minute for warm-up scaling.
     *
     *  @access  public
     *  @static
     *  @param   integer  $scaling_initial_requests_per_minute  [REQUIRED]  Allowable requests.
     *  @return  NULL
     */
    static public function set_scaling_initial_requests_per_minute( $scaling_initial_requests_per_minute ) {

        self::$scaling_initial_requests_per_minute = $scaling_initial_requests_per_minute;
    }


    /**
     *  Set the number of minutes to double warm-up scaling allowable requests per minute.
     *
     *  @access  public
     *  @static
     *  @param   float  $scaling_double_capacity_minutes  [REQUIRED]  Minutes.
     *  @return  NULL
     */
    static public function set_scaling_double_capacity_minutes( $scaling_double_capacity_minutes ) {

        self::$scaling_double_capacity_minutes = $scaling_double_capacity_minutes;
    }


    /**
     *  Set the maximum number of threads that may be utilized at any one time
     *
     *  @access  public
     *  @static
     *  @param   integer  $max_threads  [REQUIRED]  The maximum number of threads
     *  @return  NULL
     */
    static public function set_max_threads( $max_threads ) {

        self::$max_threads = $max_threads;
    }


    /**
     *  Set the number of seconds to wait between launching new threads to managably ramp up requests
     *
     *  @access  public
     *  @static
     *  @param   integer  $max_requests_per_minute  [REQUIRED]  The interval in seconds
     *                                                          between thread launches
     *  @return  NULL
     */
    static public function set_max_requests_per_minute( $max_requests_per_minute ) {

        self::$max_requests_per_minute = $max_requests_per_minute;
    }


    /**
     *  Set debug logging
     *
     *  @access  public
     *  @static
     *  @param   boolean  $debug  [REQUIRED]  Log debug info?
     *  @return  NULL
     */
    static public function set_debug($debug) {

        self::$debug = $debug;
    }


    /**
     *  Set the maximum number of times to retry a recoverable error
     *
     *  @access  public
     *  @static
     *  @param   integer  $max_retries  [REQUIRED]  The maximum number of times to retry
     *                                              a recoverable error.
     *  @return  NULL
     */
    static public function set_max_retries($max_retries) {

        self::$max_retries = $max_retries;
    }


    /**
     *  Set self::$show_progress to TRUE or FALSE
     *
     *  @access  public
     *  @static
     *  @param   boolean  $show_progress  [REQUIRED]  If set to true, every time a request is queued,
     *                                                '+' is output, every time a request is made, '-'
     *                                                is output, and every time a response is received
     *                                                for a request '×' is output.
     *  @return  NULL
     */
    static public function show_progress($show_progress) {

        self::$show_progress = $show_progress;
    }


    /**
     *  Get the status of a node
     *
     *  @access  public
     *  @return  string   Possible values: "queued", "processing", "complete", "unknown"
     */
    public function get_status() {

        if( is_array(self::$complete) && isset(self::$complete[$this->handle_string]) ) {

            return 'complete';

        } elseif( is_array(self::$active) && isset(self::$active[$this->handle_string]) ) {

            return 'processing';

        } elseif( is_array(self::$queue) && isset(self::$queue[$this->handle_string]) ) {

            return 'queued';
        }

        return 'unknown';
    }


    /**
     *  Get the result of a node request
     *
     *  @access  public
     *  @return  mixed   If a node request is not complete, returns FALSE.
     *                   If a node request has completed, returns an associative array
     *                   containing these keys: 'response' (string), 'http_code' (string),
     *                   'latency' (float), 'url' (string), 'opts' (array).
     */
    public function get_result() {

        if( isset(self::$complete[$this->handle_string]) ) {

            return self::$complete[$this->handle_string];

        } else {

            return FALSE;
        }
    }


    /**
     *  Get all results. This method waits for all node requests to complete.
     *
     *  @access  public
     *  @static
     *  @return  array  An indexed array of associative arrays containing these keys:
     *                  'response' (string), 'http_code' (string), 'latency' (float),
     *                  'url' (string), 'opts' (array)
     */
    static public function get_results() {

        self::finish();

        return isset(self::$complete) ? self::$complete : array();
    }


    /**
     *  Get debug info.
     *
     *  @access  public
     *  @static
     *  @return  string  All debug information.
     */
    static public function get_debug_info() {

        return self::$debug_info;
    }


    /**
     *  Wait for all request nodes to complete and process the results
     *
     *  @access  public
     *  @static
     *  @return  NULL
     */
    static public function finish() {

        if( self::$debug ) self::$debug_info += "Finishing\n";
        if( isset(self::$multi_handle) ) {

            do {

                self::wait_for_result();
                self::process_results();

            } while( 0 < self::$threads && CURLM_OK == self::$status );

            curl_multi_close(self::$multi_handle);
            self::$multi_handle = NULL;
        }
        if( self::$debug ) self::$debug_info += "Finished\n";
    }



    /**
     *  Add a node and process any results that may have completed
     *
     *  @access  private
     *  @static
     *  @return  NULL
     */
    static private function request() {

        self::add_nodes();
        self::process_results();
    }



    /**
     *  Add a node
     *
     *  @access  private
     *  @static
     *  @return  NULL
     */
    static private function add_nodes() {

        if( 0 == count(self::$queue) ) {

            return;
        }

        if( self::$add_nodes_lock !== TRUE ) {

            self::$add_nodes_lock = TRUE;
            self::$multi_handle   = empty(self::$multi_handle) ? curl_multi_init() : self::$multi_handle;
            self::$threads        = empty(self::$threads)      ? 0                 : self::$threads;
            self::$status         = !isset(self::$status)      ? CURLM_OK          : self::$status;


            /*  add nodes to curl requests until $max_threads added or $queue exhausted  */

            while( self::$threads < self::$max_threads && 0 < count(self::$queue) && CURLM_OK == self::$status ) {

                // add node to $active
                $node = array_shift(self::$queue);

                self::$active[(string) $node['handle']] = $node;
                curl_multi_add_handle(self::$multi_handle, $node['handle']);

                usleep( self::delay() * pow(2,$node['retries']) );

                do {
                    self::$status = curl_multi_exec(self::$multi_handle, self::$threads);
                } while( CURLM_CALL_MULTI_PERFORM == self::$status );

                if( self::$debug ) self::$debug_info += ((string) $node['handle']) . ": request submitted\n";
                if( self::$show_progress ) echo '-';
            }

            self::$add_nodes_lock = FALSE;
        }
    }


    /**
     *  Wait until activity on a node occurs
     *
     *  @access  private
     *  @static
     *  @return  NULL
     */
    static private function wait_for_result() {


            if( CURLM_OK == self::$status && 0 < self::$threads && -1 != curl_multi_select(self::$multi_handle) ) {

                do {

                    if( self::$debug ) self::$debug_info += "Waiting for response\n";

                    self::$status = curl_multi_exec(self::$multi_handle, self::$threads);

                } while (CURLM_CALL_MULTI_PERFORM == self::$status);
            }
    }


    /**
     *  Process any results that may have completed
     *
     *  @access  private
     *  @static
     *  @return  NULL
     */
    static private function process_results() {

        $processed = FALSE;

        if( self::$debug ) self::$debug_info += "Processing responses\n";

        while( FALSE !== ($info = curl_multi_info_read(self::$multi_handle)) ) {

            $processed = TRUE;
            $handle    = $info['handle'];
            $node      = self::$active[(string) $handle];
            $http_code = curl_getinfo( $node['handle'], CURLINFO_HTTP_CODE );
            unset(self::$active[(string) $handle]);

            if( self::$debug ) self::$debug_info += ((string) $handle) . ": processing response\n";

            if( in_array($http_code, array('0','403','408','500','503','504')) &&  $node['retries'] < self::$max_retries) {

                // we have an error that may be recovered from

                $node['retries']++;

                self::$queue[(string) $handle] = $node;

                if( self::$debug ) self::$debug_info += ((string) $handle) . ": recoverable error ({$http_code}), resubmitted to queue\n";
                if( self::$show_progress ) echo " +{$node['retries']} ";

            } else {

                $callback = $node['callback'];

                $node['latency']    = microtime(TRUE) - $node['start'];
                $node['http_code']  = (string) $http_code;
                $node['response']   = ( $http_code != 0 ) ? curl_multi_getcontent($handle) : curl_error($handle);
                unset($node['handle']);
                unset($node['start']);
                unset($node['retries']);
                unset($node['callback']);

                // we will for a $result array that allows $node['response'] to be passed by reference to user defined callback
                $callback_params = array(
                    &$node['response'],
                    &$node['metadata'],
                    &$node['http_code'],
                    &$node['latency'],
                    &$node['url'],
                    &$node['opts']
                );

                if( !empty($callback) && is_callable($callback) ) {

                    if( self::$debug ) self::$debug_info += ((string) $handle) . ": sending response to callback function\n";
                    call_user_func_array( $callback, $callback_params );
                }

                // if the user set a node value to null in the callback function, just unset the parameter to save memory
                if( $node['response']  === NULL ) unset($node['response']);
                if( $node['metadata']  === NULL ) unset($node['metadata']);
                if( $node['http_code'] === NULL ) unset($node['http_code']);
                if( $node['latency']   === NULL ) unset($node['latency']);
                if( $node['url']       === NULL ) unset($node['url']);
                if( $node['opts']      === NULL ) unset($node['opts']);

                self::$complete[(string) $handle] = $node;

                if( self::$debug ) self::$debug_info += ((string) $handle) . ": response processed\n";
                if( self::$show_progress ) echo '×';
            }

            curl_multi_remove_handle(self::$multi_handle, $handle);
        }

        if( $processed && 0 < count(self::$queue) ) {

            self::add_nodes();
        }
    }


    /**
     *  Get request delay in microseconds
     *
     *  @access  private
     *  @static
     *  @return  integer  The microseconds to delay between requests
     */
    static private function delay() {

        $scaling_minutes_elapsed     = (time() - self::$scaling_initialization_timestamp) / 60;
        $scaling_requests_per_minute = self::$scaling_initial_requests_per_minute * pow(2, $scaling_minutes_elapsed / self::$scaling_double_capacity_minutes);
        $scaling_delay_microseconds  = (60/$scaling_requests_per_minute) * 1000000;
        $min_delay_microseconds      = (60/self::$max_requests_per_minute) * 1000000;

        return max($scaling_delay_microseconds, $min_delay_microseconds);
    }
}


?>